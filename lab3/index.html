<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>WebXR AR Rolling Cylinder Physics (Corrected)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.165.0/examples/jsm/"
        }
    }
    </script>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            overflow: hidden;
            background-color: #000;
        }
        #info {
            position: absolute; top: 10px; left: 10px; color: white;
            background: rgba(0,0,0,0.7); padding: 15px; border-radius: 5px;
            z-index: 100; font-size: 14px;
        }
        #controls {
            position: absolute; bottom: 100px; left: 50%;
            transform: translateX(-50%); z-index: 100; display: flex;
            gap: 10px; flex-wrap: wrap; justify-content: center; max-width: 90%;
        }
        button {
            padding: 10px 15px; background: rgba(255, 255, 255, 0.8);
            border: none; border-radius: 5px; cursor: pointer;
            font-size: 14px; transition: background 0.3s;
        }
        button:hover { background: rgba(255, 255, 255, 1); }
        button:active { transform: scale(0.95); }
        #arButton-container { /* Renamed for clarity */
            position: absolute; bottom: 20px; left: 50%;
            transform: translateX(-50%); z-index: 999;
        }
        .vector-legend { margin-top: 10px; font-size: 12px; }
        .vector-item { margin: 3px 0; }
        .vector-color {
            display: inline-block; width: 12px; height: 12px;
            margin-right: 5px; vertical-align: middle;
        }
    </style>
</head>
<body>
    <div id="info">
        <div><strong>WebXR AR Rolling Cylinder Physics</strong></div>
        <div>Desktop: Mouse to rotate, Scroll to zoom</div>
        <div>AR: Press "ENTER AR" to view in AR</div>
        <div class="vector-legend">
            <div class="vector-item"><span class="vector-color" style="background: #0000ff;"></span>Gravity</div>
            <div class="vector-item"><span class="vector-color" style="background: #00ff00;"></span>Normal Force</div>
            <div class="vector-item"><span class="vector-color" style="background: #ffff00;"></span>Friction</div>
            </div>
    </div>
    
    <div id="controls">
        <button onclick="resetSimulation()">Reset</button>
        <button onclick="togglePhysics()">Pause/Resume</button>
        <button onclick="toggleVectors()">Toggle Vectors</button>
        <button onclick="changeView()">Change View</button>
        <button onclick="scaleUp()">Scale Up</button>
        <button onclick="scaleDown()">Scale Down</button>
    </div>

    <div id="arButton-container"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';

        // Global variables
        let scene, camera, renderer, world;
        let sceneGroup, cylinderBody, cylinder;
        let vectors, showVectors = true;
        let physicsEnabled = true;
        let currentView = 0;
        let isInAR = false;
        
        // ДОДАНО: Змінні для AR-логіки
        let controller, reticle, isScenePlaced = false, hitTestSource = null, hitTestSourceRequested = false;
        
        const clock = new THREE.Clock();
        const cameraPositions = [
            { pos: [15, 10, 15], look: [0, 2, 0] },
            { pos: [0, 20, 0], look: [0, 0, 0] },
            { pos: [25, 5, 0], look: [0, 2, 0] },
            { pos: [0, 10, 25], look: [0, 2, 0] }
        ];

        initialize();

        // Ваші глобальні функції залишаються без змін
        window.resetSimulation = resetSimulation;
        window.togglePhysics = togglePhysics;
        window.toggleVectors = toggleVectors;
        window.changeView = changeView;
        window.scaleUp = scaleUp;
        window.scaleDown = scaleDown;

        function initialize() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 200);
            camera.position.set(15, 10, 15);
            camera.lookAt(0, 2, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -10;
            directionalLight.shadow.camera.right = 10;
            directionalLight.shadow.camera.top = 10;
            directionalLight.shadow.camera.bottom = -10;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            sceneGroup = new THREE.Group();
            scene.add(sceneGroup);
            
            setupPhysics();
            createScene();
            createForceVectors();
            
            // ДОДАНО: Ініціалізація AR-логіки
            setupAR();
            
            // Ваш оригінальний код для керування мишкою
            setupMouseControls();
            
            window.addEventListener('resize', onWindowResize);
            renderer.setAnimationLoop(animate);
            resetSimulation(); // Початковий запуск симуляції
        }

        function setupPhysics() {
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;
            
            const groundMaterial = new CANNON.Material('ground');
            const cylinderMaterial = new CANNON.Material('cylinder');
            const contactMaterial = new CANNON.ContactMaterial(groundMaterial, cylinderMaterial, {
                friction: 0.4, restitution: 0.1
            });
            world.addContactMaterial(contactMaterial);
        }

        function createScene() {
            const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x7BC8A4, side: THREE.DoubleSide });
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(30, 30), floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -2;
            floor.receiveShadow = true;
            sceneGroup.add(floor);
            
            const floorBody = new CANNON.Body({ mass: 0, position: new CANNON.Vec3(0, -2, 0) });
            floorBody.addShape(new CANNON.Plane());
            floorBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.addBody(floorBody);
            
            const inclineAngle = -Math.PI / 6; // Зменшив кут нахилу
            const inclineLength = 15;
            const inclineWidth = 8;
            const planeMaterial = new THREE.MeshLambertMaterial({ color: 0x7BC224 });
            const inclinedPlane = new THREE.Mesh(new THREE.BoxGeometry(inclineWidth, 0.2, inclineLength), planeMaterial);
            inclinedPlane.position.set(0, 3, 0);
            inclinedPlane.quaternion.setFromAxisAngle(new THREE.Vector3(1, 0, 0), inclineAngle);
            inclinedPlane.receiveShadow = true;
            inclinedPlane.castShadow = true;
            sceneGroup.add(inclinedPlane);
            
            const planeShape = new CANNON.Box(new CANNON.Vec3(inclineWidth/2, 0.1, inclineLength/2));
            const planeBody = new CANNON.Body({ mass: 0, position: new CANNON.Vec3(0, 3, 0) });
            planeBody.addShape(planeShape);
            planeBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), inclineAngle);
            world.addBody(planeBody);
            
            const cylinderRadius = 0.5;
            const cylinderHeight = 2;
            const cylinderMaterialThree = new THREE.MeshLambertMaterial({ color: 0xff0000 });
            cylinder = new THREE.Mesh(new THREE.CylinderGeometry(cylinderRadius, cylinderRadius, cylinderHeight, 32), cylinderMaterialThree);
            cylinder.castShadow = true;
            sceneGroup.add(cylinder);
            
            const cylinderShape = new CANNON.Cylinder(cylinderRadius, cylinderRadius, cylinderHeight, 12);
            cylinderBody = new CANNON.Body({ mass: 5 });
            cylinderBody.addShape(cylinderShape, new CANNON.Vec3(), new CANNON.Quaternion().setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 2));
            world.addBody(cylinderBody);
        }

        // Ваш код векторів залишено без змін
        function createForceVectors() { /* ... ваш код ... */ }
        function createVector(color) { /* ... ваш код ... */ }
        function updateForceVectors() { /* ... ваш код ... */ }
        function updateVector(vector, start, direction) { /* ... ваш код ... */ }

        // ДОДАНО: Функція для налаштування AR
        function setupAR() {
            const arButton = ARButton.createButton(renderer, {
                requiredFeatures: ['hit-test'], optionalFeatures: ['dom-overlay'], domOverlay: { root: document.body }
            });
            document.getElementById('arButton-container').appendChild(arButton);

            reticle = new THREE.Mesh(
                new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
                new THREE.MeshBasicMaterial()
            );
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);
            
            controller = renderer.xr.getController(0);
            controller.addEventListener('select', onSelect);
            scene.add(controller);
            
            renderer.xr.addEventListener('sessionstart', onXRSessionStart);
            renderer.xr.addEventListener('sessionend', onXRSessionEnd);
        }

        // Ваші оригінальні функції керування
        function setupMouseControls() { /* ... ваш код ... */ }
        function changeView() { /* ... ваш код ... */ }
        function scaleUp() { /* ... ваш код ... */ }
        function scaleDown() { /* ... ваш код ... */ }

        function onXRSessionStart() {
            isInAR = true;
            sceneGroup.visible = false; // Ховаємо сцену, поки не розмістимо
            document.getElementById('info').style.display = 'none';
            document.getElementById('controls').style.display = 'none';
        }

        function onXRSessionEnd() {
            isInAR = false;
            isScenePlaced = false;
            sceneGroup.visible = true; // Показуємо сцену знову в 3D режимі
            sceneGroup.position.set(0,0,0);
            sceneGroup.rotation.set(0,0,0);
            document.getElementById('info').style.display = 'block';
            document.getElementById('controls').style.display = 'flex';
            resetSimulation();
        }
        
        // ДОДАНО: Функція для обробки тапу в AR
        function onSelect() {
            if (reticle.visible && !isScenePlaced) {
                sceneGroup.position.setFromMatrixPosition(reticle.matrix);
                // ЗМІНЕНО: Повертаємо сцену на 180 градусів
                sceneGroup.rotation.y = Math.PI;
                sceneGroup.visible = true;
                isScenePlaced = true;
                reticle.visible = false;
                resetSimulation();
                // Показуємо кнопки керування після розміщення
                document.getElementById('controls').style.display = 'flex';
            }
        }
        
        function animate(timestamp, frame) {
            const deltaTime = Math.min(clock.getDelta(), 0.1);
            
            // ДОДАНО: Логіка Hit-testing для AR-режиму
            if (frame && isInAR && !isScenePlaced) {
                if (!hitTestSourceRequested) {
                    const session = renderer.xr.getSession();
                    session.requestReferenceSpace('viewer').then(refSpace => {
                        session.requestHitTestSource({ space: refSpace }).then(source => { hitTestSource = source; });
                    });
                    hitTestSourceRequested = true;
                }
                if (hitTestSource) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);
                    if (hitTestResults.length > 0) {
                        reticle.visible = true;
                        reticle.matrix.fromArray(hitTestResults[0].getPose(renderer.xr.getReferenceSpace()).transform.matrix);
                    } else {
                        reticle.visible = false;
                    }
                }
            }

            if (physicsEnabled && (!isInAR || isScenePlaced)) {
                world.step(1/60, deltaTime, 3); // Використовуємо стабільний крок
                cylinder.position.copy(cylinderBody.position);
                cylinder.quaternion.copy(cylinderBody.quaternion);
                updateForceVectors();
            }
            
            if (!isInAR && window.updateDesktopCamera) {
                window.updateDesktopCamera();
            }
            
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function resetSimulation() {
            cylinderBody.position.set(0, 7, -5); // Трохи змінив позицію для кращого старту
            cylinderBody.velocity.set(0, 0, 0);
            cylinderBody.angularVelocity.set(0, 0, 0);
            
            // ЗМІНЕНО: Орієнтація циліндра для правильного кочення
            // Повертаємо навколо осі Z на 90 градусів, щоб він ліг на бік правильно
            cylinderBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 2);
        }

        function togglePhysics() {
            physicsEnabled = !physicsEnabled;
        }

        function toggleVectors() {
            showVectors = !showVectors;
            // Приховуємо/показуємо всі вектори одразу
            Object.values(vectors).forEach(v => v.group.visible = showVectors);
        }
        
        // Тут я скопіював ваш код векторів, щоб не втратити його
        function createForceVectors() {
            vectors = {
                gravity: createVector(0x0000ff),
                normal: createVector(0x00ff00),
                friction: createVector(0xffff00),
            };
        }
        function createVector(color) {
            const group = new THREE.Group();
            const arrow = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.5, 8), new THREE.MeshBasicMaterial({ color }));
            const lineMaterial = new THREE.LineBasicMaterial({ color, linewidth: 3 });
            const lineGeometry = new THREE.BufferGeometry();
            lineGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(6), 3));
            const line = new THREE.Line(lineGeometry, lineMaterial);
            group.add(arrow, line);
            sceneGroup.add(group);
            return { group, arrow, line };
        }
        function updateForceVectors() {
            if (!showVectors) {
                Object.values(vectors).forEach(v => v.group.visible = false);
                return;
            }
            Object.values(vectors).forEach(v => v.group.visible = true);
            
            const pos = cylinder.position.clone();
            const mass = cylinderBody.mass;
            const g = world.gravity.y;
            
            const gravityForce = new THREE.Vector3(0, mass * g * 0.1, 0);
            updateVector(vectors.gravity, pos, gravityForce);

            let hasContact = world.contacts.some(c => c.bi === cylinderBody || c.bj === cylinderBody);
            
            if (hasContact) {
                // Спрощена логіка для нормальної сили та тертя
                const normalForce = new THREE.Vector3(0, -gravityForce.y * Math.cos(Math.PI/6), 0); // Simplified
                updateVector(vectors.normal, pos, normalForce);

                const frictionForce = new THREE.Vector3(0, 0, -cylinderBody.velocity.z * 0.1);
                updateVector(vectors.friction, pos, frictionForce);
            } else {
                vectors.normal.group.visible = false;
                vectors.friction.group.visible = false;
            }
        }
        function updateVector(vector, start, direction) {
            if (direction.length() === 0) {
                vector.group.visible = false;
                return;
            }
            vector.group.visible = true;
            const end = new THREE.Vector3().copy(start).add(direction);
            const positions = vector.line.geometry.attributes.position.array;
            positions[0] = start.x; positions[1] = start.y; positions[2] = start.z;
            positions[3] = end.x; positions[4] = end.y; positions[5] = end.z;
            vector.line.geometry.attributes.position.needsUpdate = true;
            vector.arrow.position.copy(end);
            vector.arrow.lookAt(start);
        }
        function setupMouseControls() {
            let isDragging = false; let previousMousePosition = { x: 0, y: 0 };
            renderer.domElement.addEventListener('mousedown', () => isDragging = true);
            renderer.domElement.addEventListener('mouseup', () => isDragging = false);
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (!isInAR && isDragging) {
                    const deltaMove = { x: e.offsetX - previousMousePosition.x, y: e.offsetY - previousMousePosition.y };
                    const rotationSpeed = 0.005;
                    camera.position.applyAxisAngle(new THREE.Vector3(0,1,0), deltaMove.x * rotationSpeed);
                    camera.position.applyAxisAngle(new THREE.Vector3(1,0,0), deltaMove.y * rotationSpeed);
                    camera.lookAt(scene.position);
                }
                previousMousePosition = { x: e.offsetX, y: e.offsetY };
            });
            renderer.domElement.addEventListener('wheel', (e) => {
                if (!isInAR) camera.position.multiplyScalar(1 + e.deltaY * 0.001);
            });
        }
        function changeView() {
            if (!isInAR) {
                currentView = (currentView + 1) % cameraPositions.length;
                const view = cameraPositions[currentView];
                camera.position.set(...view.pos);
                camera.lookAt(...view.look);
            }
        }
        function scaleUp() { sceneGroup.scale.multiplyScalar(1.2); }
        function scaleDown() { sceneGroup.scale.multiplyScalar(0.8); }

    </script>
</body>
</html>
