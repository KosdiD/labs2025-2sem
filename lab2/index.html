<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AR Rolling Cylinder with Three.js</title>
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.1.4/dist/mindar-image-three.prod.js"></script>
  <style>
    body { margin: 0; overflow: hidden; }
    #container { position: absolute; width: 100%; height: 100%; }
    #ui { position: absolute; bottom: 20px; left: 20px; color: white; background: rgba(0,0,0,0.5); padding: 10px; }
    .vector-label { position: absolute; font-family: Arial; font-size: 12px; color: white; }
  </style>
</head>
<body>
  <div id="container"></div>
  <div id="ui">
    <div>Waiting for marker detection...</div>
    <div id="position-info"></div>
    <div id="velocity-info"></div>
  </div>

  <script>
    // Main variables
    let scene, renderer, camera, physicsWorld;
    let cylinderBody, cylinderMesh;
    let arScene, mindarThree;
    let isTracking = false;
    
    // Physics parameters
    const fixedTimeStep = 1.0 / 60.0;
    const maxSubSteps = 3;
    
    // Vector visualization
    let gravityVector, normalVector, frictionVector, impulseVector;
    let gravityArrow, normalArrow, frictionArrow, impulseArrow;
    let gravityLabel, normalLabel, frictionLabel, impulseLabel;
    
    // Initialize the application
    async function init() {
      // Set up Three.js scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);
      
      // Set up renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.getElementById('container').appendChild(renderer.domElement);
      
      // Set up physics world
      setupPhysics();
      
      // Set up MindAR
      await setupAR();
      
      // Create 3D objects
      createScene();
      
      // Start animation loop
      animate();
      
      // Handle window resize
      window.addEventListener('resize', onWindowResize);
    }
    
    // Set up Cannon.js physics
    function setupPhysics() {
      physicsWorld = new CANNON.World();
      physicsWorld.gravity.set(0, -9.82, 0);
      physicsWorld.broadphase = new CANNON.NaiveBroadphase();
      physicsWorld.solver.iterations = 10;
    }
    
    // Set up MindAR
    async function setupAR() {
      mindarThree = new window.MINDAR.IMAGE.MindARThree({
        container: document.getElementById('container'),
        imageTargetSrc: './rolling.mind',
      });
      
      const { renderer: arRenderer, scene: arScene, camera: arCamera } = mindarThree;
      
      // Start AR
      await mindarThree.start();
      
      // Add event listeners
      arScene.addEventListener('targetFound', (event) => {
        isTracking = true;
        document.getElementById('ui').innerHTML = '<div>Marker detected</div><div id="position-info"></div><div id="velocity-info"></div>';
      });
      
      arScene.addEventListener('targetLost', (event) => {
        isTracking = false;
      });
    }
    
    // Create 3D scene
    function createScene() {
      // Floor
      const floorGeometry = new THREE.PlaneGeometry(20, 20);
      const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x7BC8A4 });
      const floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
      floorMesh.rotation.x = -Math.PI / 2;
      floorMesh.receiveShadow = true;
      
      // Floor physics
      const floorShape = new CANNON.Plane();
      const floorBody = new CANNON.Body({ mass: 0 });
      floorBody.addShape(floorShape);
      floorBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
      physicsWorld.addBody(floorBody);
      
      // Inclined plane
      const inclinedGeometry = new THREE.PlaneGeometry(10, 80);
      const inclinedMaterial = new THREE.MeshStandardMaterial({ color: 0x7BC224 });
      const inclinedMesh = new THREE.Mesh(inclinedGeometry, inclinedMaterial);
      inclinedMesh.rotation.x = -Math.PI / 4;
      inclinedMesh.position.y = 5;
      inclinedMesh.receiveShadow = true;
      
      // Inclined plane physics
      const inclinedShape = new CANNON.Plane();
      const inclinedBody = new CANNON.Body({ mass: 0 });
      inclinedBody.addShape(inclinedShape);
      inclinedBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 4);
      inclinedBody.position.set(0, 5, 0);
      physicsWorld.addBody(inclinedBody);
      
      // Cylinder
      const cylinderGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 32);
      const cylinderMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
      cylinderMesh = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
      cylinderMesh.rotation.z = Math.PI / 2;
      cylinderMesh.position.set(0, 35, -10);
      cylinderMesh.castShadow = true;
      
      // Cylinder physics
      const cylinderShape = new CANNON.Cylinder(0.5, 0.5, 2, 32);
      cylinderBody = new CANNON.Body({
        mass: 10,
        shape: cylinderShape,
        linearDamping: 0.1,
        angularDamping: 0.1
      });
      cylinderBody.position.set(0, 35, -10);
      cylinderBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 0, 1), Math.PI / 2);
      physicsWorld.addBody(cylinderBody);
      
      // Apply initial impulse
      setTimeout(() => {
        const impulse = new CANNON.Vec3(0, 0, 5);
        const worldPoint = new CANNON.Vec3().copy(cylinderBody.position);
        cylinderBody.applyImpulse(impulse, worldPoint);
      }, 1000);
      
      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(10, 20, 0);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      scene.add(directionalLight);
      
      // Create vector visualizations
      createVectorVisualizations();
      
      // Add objects to scene
      scene.add(floorMesh);
      scene.add(inclinedMesh);
      scene.add(cylinderMesh);
    }
    
    // Create vector visualization objects
    function createVectorVisualizations() {
      // Gravity vector
      const gravityDir = new THREE.Vector3(0, -1, 0);
      gravityVector = new THREE.ArrowHelper(
        gravityDir.clone().normalize(),
        new THREE.Vector3(0, 0, 0),
        2,
        0x0000ff,
        0.1,
        0.1
      );
      gravityVector.visible = false;
      scene.add(gravityVector);
      
      // Normal vector
      normalVector = new THREE.ArrowHelper(
        new THREE.Vector3(0, 1, 0),
        new THREE.Vector3(0, 0, 0),
        2,
        0x00ff00,
        0.1,
        0.1
      );
      normalVector.visible = false;
      scene.add(normalVector);
      
      // Friction vector
      frictionVector = new THREE.ArrowHelper(
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, 0, 0),
        2,
        0xffff00,
        0.1,
        0.1
      );
      frictionVector.visible = false;
      scene.add(frictionVector);
      
      // Impulse vector
      impulseVector = new THREE.ArrowHelper(
        new THREE.Vector3(0, 0, 1),
        new THREE.Vector3(0, 0, 0),
        2,
        0xff0000,
        0.1,
        0.1
      );
      impulseVector.visible = false;
      scene.add(impulseVector);
      
      // Show all vectors after a short delay
      setTimeout(() => {
        gravityVector.visible = true;
        normalVector.visible = true;
        frictionVector.visible = true;
        impulseVector.visible = true;
      }, 1500);
    }
    
    // Update vector visualizations
    function updateVectors() {
      if (!cylinderBody) return;
      
      const pos = cylinderBody.position;
      const mass = cylinderBody.mass;
      const g = 9.82;
      
      // Update gravity vector
      gravityVector.position.set(pos.x, pos.y, pos.z);
      gravityVector.setDirection(new THREE.Vector3(0, -1, 0));
      gravityVector.setLength(mass * g * 0.1);
      
      // Update normal vector (when on ground)
      if (pos.y <= 0.5) {
        normalVector.position.set(pos.x, pos.y, pos.z);
        normalVector.setDirection(new THREE.Vector3(0, 1, 0));
        normalVector.setLength(mass * g * 0.1);
      }
      
      // Update friction vector
      const velocity = cylinderBody.velocity;
      if (velocity.length() > 0.1) {
        const frictionDir = new THREE.Vector3(
          -velocity.x * 0.5 / velocity.length(),
          -velocity.y * 0.5 / velocity.length(),
          -velocity.z * 0.5 / velocity.length()
        );
        frictionVector.position.set(pos.x, pos.y, pos.z);
        frictionVector.setDirection(frictionDir.normalize());
        frictionVector.setLength(frictionDir.length());
      }
      
      // Update impulse vector
      if (velocity.z > 0.1) {
        impulseVector.position.set(pos.x, pos.y, pos.z);
        impulseVector.setDirection(new THREE.Vector3(0, 0, 1));
        impulseVector.setLength(1);
      }
      
      // Update UI info
      document.getElementById('position-info').textContent = 
        `Position: (${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})`;
      document.getElementById('velocity-info').textContent = 
        `Velocity: (${velocity.x.toFixed(2)}, ${velocity.y.toFixed(2)}, ${velocity.z.toFixed(2)})`;
    }
    
    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      
      // Update physics
      physicsWorld.step(fixedTimeStep);
      
      // Sync Three.js objects with physics bodies
      if (cylinderBody && cylinderMesh) {
        cylinderMesh.position.copy(cylinderBody.position);
        cylinderMesh.quaternion.copy(cylinderBody.quaternion);
      }
      
      // Update vector visualizations
      updateVectors();
      
      // Render only when tracking
      if (isTracking) {
        renderer.render(scene, camera);
      }
    }
    
    // Handle window resize
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    // Start the application
    init();
  </script>
</body>
</html>
