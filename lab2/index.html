<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Rolling Cylinder with MindAR and CANNON Physics</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="info">
        Rolling Cylinder Physics with MindAR<br>
        Marker: ../patterns/target.mind<br>
        Cylinder resets every 7 seconds
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.1.4/dist/mindar-image-three.prod.js"></script>
    
    <script>
        document.addEventListener("DOMContentLoaded", async () => {
            // Initialize MindAR
            const mindarThree = new window.MINDAR.IMAGE.MindARThree({
                container: document.body,
                imageTargetSrc: "../patterns/target.mind",
            });

            const { renderer, scene, camera } = mindarThree;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Add anchor
            const anchor = mindarThree.addAnchor(0);
            const group = new THREE.Group();
            group.scale.set(0.5, 0.5, 0.5); // Adjusted scale
            anchor.group.add(group);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 15, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Physics world
            const world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;

            // Materials
            const groundMaterial = new CANNON.Material('ground');
            const cylinderMaterial = new CANNON.Material('cylinder');
            
            const contactMaterial = new CANNON.ContactMaterial(groundMaterial, cylinderMaterial, {
                friction: 0.4,
                restitution: 0.1
            });
            world.addContactMaterial(contactMaterial);

            // Ground floor
            const floorGeometry = new THREE.PlaneGeometry(30, 30);
            const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x7BC8A4 });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -2;
            floor.receiveShadow = true;
            group.add(floor);

            const floorShape = new CANNON.Box(new CANNON.Vec3(15, 15, 0.1));
            const floorBody = new CANNON.Body({
                mass: 0,
                material: groundMaterial,
                position: new CANNON.Vec3(0, -2, 0)
            });
            floorBody.addShape(floorShape);
            floorBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.add(floorBody);

            // Inclined plane
            const inclineAngle = Math.PI / 4; // 45 degrees
            const inclineLength = 15;
            const inclineWidth = 8;

            const planeGeometry = new THREE.BoxGeometry(inclineWidth, 0.2, inclineLength);
            const planeMaterial = new THREE.MeshLambertMaterial({ color: 0x7BC224 });
            const inclinedPlane = new THREE.Mesh(planeGeometry, planeMaterial);
            inclinedPlane.position.set(0, 3, 0);
            inclinedPlane.rotation.x = -inclineAngle;
            inclinedPlane.receiveShadow = true;
            inclinedPlane.castShadow = true;
            group.add(inclinedPlane);

            const planeShape = new CANNON.Box(new CANNON.Vec3(inclineWidth/2, 0.1, inclineLength/2));
            const planeBody = new CANNON.Body({
                mass: 0,
                material: groundMaterial,
                position: new CANNON.Vec3(0, 3, 0)
            });
            planeBody.addShape(planeShape);
            planeBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -inclineAngle);
            world.add(planeBody);

            // Cylinder
            const cylinderRadius = 0.5;
            const cylinderHeight = 2;
            const cylinderGeometry = new THREE.CylinderGeometry(cylinderRadius, cylinderRadius, cylinderHeight, 32);
            const cylinderMaterialThree = new THREE.MeshLambertMaterial({ color: 0xff0000 });
            const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterialThree);
            cylinder.castShadow = true;
            cylinder.receiveShadow = true;
            group.add(cylinder);

            // Cylinder physics
            const cylinderShape = new CANNON.Cylinder(cylinderRadius, cylinderRadius, cylinderHeight, 12);
            const cylinderBody = new CANNON.Body({
                mass: 5,
                material: cylinderMaterial
            });

            // Rotate cylinder shape to match Three.js orientation
            const quaternion = new CANNON.Quaternion();
            quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            cylinderBody.addShape(cylinderShape, new CANNON.Vec3(), quaternion);
            world.add(cylinderBody);

            // Initial position and rotation with auto-reset every 7 seconds
            let lastResetTime = 0;
            
            function resetCylinder() {
                cylinderBody.position.set(0, 7, -4);
                cylinderBody.velocity.set(0, 0, 0);
                cylinderBody.angularVelocity.set(0, 0, 0);
                cylinderBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 0, 1), Math.PI / 2);
                
                // Apply initial impulse
                const impulse = new CANNON.Vec3(0, 0, 3);
                const worldPoint = new CANNON.Vec3().copy(cylinderBody.position);
                cylinderBody.applyImpulse(impulse, worldPoint);
                
                lastResetTime = Date.now();
            }
            resetCylinder();

            // Animation loop
            const clock = new THREE.Clock();
            
            function animate() {
                requestAnimationFrame(animate);
                
                const deltaTime = Math.min(clock.getDelta(), 0.1);
                world.step(deltaTime);
                
                // Update cylinder
                cylinder.position.copy(cylinderBody.position);
                cylinder.quaternion.copy(cylinderBody.quaternion);
                
                // Auto-reset every 7 seconds
                if (Date.now() - lastResetTime > 7000) {
                    resetCylinder();
                }
                
                // Rotate group left and right
                const time = Date.now() * 0.001;
                group.rotation.y = Math.sin(time * 0.5) * 0.5; // Gentle swaying motion
            }

            // Start MindAR
            await mindarThree.start();
            animate();

            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        });
    </script>
</body>
</html>
